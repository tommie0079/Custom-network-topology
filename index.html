<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Network Flow Status</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/lucide@latest"></script>

  <style>
    :root { --bg:#0f172a; --muted:#94a3b8; }
    body { margin:0; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: #0b1220; color:#e6eef8; height:100vh; overflow:hidden; user-select: none; }
    
    #viewport { width: 100%; height: 100%; overflow: hidden; cursor: grab; }
    #viewport:active { cursor: grabbing; }
    #world { transform-origin: 0 0; width: 100%; height: 100%; position: relative; }

    #grid-layer { width: 300%; height: 300%; position: absolute; top: 0; left: 0; pointer-events: none; background-size: 5vw 5vh; }
    .grid-bg { background-image: linear-gradient(to right, rgba(255, 255, 255, 0.05) 1px, transparent 1px), linear-gradient(to bottom, rgba(255, 255, 255, 0.05) 1px, transparent 1px); }
    .grid-label { position: absolute; font-family: monospace; font-size: 10px; color: rgba(255,255,255,0.2); pointer-events: none; display: flex; align-items: center; justify-content: center; }

    .card { background: rgba(30, 41, 59, 0.82); backdrop-filter: blur(8px); border: 1px solid rgba(255,255,255,0.04); border-radius: 14px; }
    .node-container { position: absolute; transform: translate(-50%,-50%); z-index: 10; transition: top 0.5s, left 0.5s; }
    #connections-layer { position:absolute; top:0; left:0; width:100%; height:100%; z-index:0; pointer-events:none; overflow:visible; }

    @keyframes flow { 0% { stroke-dashoffset: 24; } 100% { stroke-dashoffset: 0; } }
    .animate-flow { animation: flow 1s linear infinite; }
    @keyframes flow-reverse { 0% { stroke-dashoffset: 0; } 100% { stroke-dashoffset: 24; } }
    .animate-flow-reverse { animation: flow-reverse 1s linear infinite; }

    /* --- HOST LIST PANEL --- */
    #host-list-panel {
        position: absolute;
        bottom: 20px;
        right: 20px;
        width: 280px;
        max-height: 400px;
        background: rgba(15, 23, 42, 0.9);
        backdrop-filter: blur(12px);
        border: 1px solid rgba(255,255,255,0.1);
        border-radius: 12px;
        z-index: 50;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        box-shadow: 0 10px 30px -5px rgba(0, 0, 0, 0.5);
    }
    #host-list-header {
        padding: 12px 16px;
        background: rgba(255,255,255,0.03);
        border-bottom: 1px solid rgba(255,255,255,0.05);
        font-weight: 700;
        font-size: 13px;
        color: #94a3b8;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    #host-list-content {
        overflow-y: auto;
        padding: 8px 0;
    }
    /* Scrollbar styling */
    #host-list-content::-webkit-scrollbar { width: 6px; }
    #host-list-content::-webkit-scrollbar-track { background: transparent; }
    #host-list-content::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 3px; }
    
    .host-row {
        padding: 8px 16px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-size: 12px;
        border-bottom: 1px solid rgba(255,255,255,0.02);
        transition: background 0.2s;
    }
    .host-row:hover { background: rgba(255,255,255,0.05); }
    .host-row:last-child { border-bottom: none; }
    .status-dot { width: 8px; height: 8px; border-radius: 50%; margin-right: 10px; }
    .status-text { font-family: monospace; color: #64748b; font-size: 11px; }
  </style>
</head>
<body>

  <div style="position:absolute; top:18px; left:50%; transform:translateX(-50%); z-index: 50; text-align:center; pointer-events:none;">
    <h1 style="margin:0; font-size:20px; font-weight:700; color:#fff; letter-spacing:1px; text-shadow: 0 2px 4px rgba(0,0,0,0.5);">NETWORK TOPOLOGY</h1>
    <div id="last-updated" style="font-family:monospace; font-size:11px; color:var(--muted); margin-top:6px; text-shadow: 0 1px 2px rgba(0,0,0,0.5);">Initializing...</div>
  </div>

  <div id="viewport">
    <div id="world">
      <div id="grid-layer" class="grid-bg"><div id="grid-labels"></div></div>
      <svg id="connections-layer" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="none"></svg>
      <div id="tree-container" style="position:absolute; inset:0; z-index:20; pointer-events:none;"></div>
    </div>
  </div>

  <!-- HOST LIST PANEL -->
  <div id="host-list-panel">
      <div id="host-list-header">
          <span>Host Status</span>
          <span id="host-count" class="text-xs bg-slate-800 px-2 py-0.5 rounded text-slate-400">0</span>
      </div>
      <div id="host-list-content">
          <!-- Rows injected here -->
      </div>
  </div>

<script>
  lucide.createIcons();
  const clientPollMs = 1000;
  let networkData = [];
  
  // Zoom/Pan Variables
  let scale = 1, pointX = 0, pointY = 0, isPanning = false, startX = 0, startY = 0;
  const viewport = document.getElementById('viewport');
  const world = document.getElementById('world');

  // --- GRID SYSTEM ---
  function drawGridSystem() {
    const labelContainer = document.getElementById('grid-labels');
    labelContainer.innerHTML = '';
    const cols = [];
    for(let i=0; i<26; i++) cols.push(String.fromCharCode(65+i));
    for(let i=0; i<26; i++) cols.push('A'+String.fromCharCode(65+i)); 

    cols.forEach((char, i) => {
        const el = document.createElement('div');
        el.className = 'grid-label'; el.innerText = char;
        el.style.top = '0'; el.style.left = (i * 5) + 'vw'; el.style.width = '5vw'; el.style.height = '20px'; 
        labelContainer.appendChild(el);
    });
    for(let i=1; i<=50; i++) {
        const el = document.createElement('div');
        el.className = 'grid-label'; el.innerText = i;
        el.style.left = '0'; el.style.top = ((i - 1) * 5) + 'vh'; el.style.height = '5vh'; el.style.width = '20px'; 
        el.style.justifyContent = 'flex-start'; el.style.paddingLeft = '4px';
        labelContainer.appendChild(el);
    }
  }
  drawGridSystem();

  // --- ZOOM & PAN HANDLERS ---
  viewport.addEventListener('wheel', (e) => {
    e.preventDefault();
    const xs = (e.clientX - pointX) / scale, ys = (e.clientY - pointY) / scale;
    const delta = -e.deltaY;
    scale = delta > 0 ? scale * 1.1 : scale / 1.1;
    scale = Math.min(Math.max(0.1, scale), 5); 
    pointX = e.clientX - xs * scale; pointY = e.clientY - ys * scale;
    updateTransform();
  });
  viewport.addEventListener('mousedown', (e) => { isPanning = true; startX = e.clientX - pointX; startY = e.clientY - pointY; });
  window.addEventListener('mousemove', (e) => {
    if (!isPanning) return;
    e.preventDefault();
    pointX = e.clientX - startX; pointY = e.clientY - startY;
    updateTransform();
  });
  window.addEventListener('mouseup', () => isPanning = false);
  function updateTransform() { world.style.transform = `translate(${pointX}px, ${pointY}px) scale(${scale})`; }

  // --- DATA HANDLER ---
  window.setNetworkData = function(data) {
    try {
      if (!data || !Array.isArray(data.nodes)) return;
      networkData = data.nodes;
      document.getElementById('last-updated').textContent = 'Last Update: ' + (data.updated || new Date().toLocaleTimeString());
      
      if (data.settings && data.settings.showGrid === false) document.getElementById('grid-layer').style.display = 'none';
      else document.getElementById('grid-layer').style.display = 'block';

      renderTree(networkData);
      renderHostList(networkData); // Update List
    } catch (e) { console.error(e); }
  };

  // --- NEW: RENDER HOST LIST ---
  function renderHostList(nodes) {
      const list = document.getElementById('host-list-content');
      document.getElementById('host-count').innerText = nodes.length;
      
      // We re-render content. For better performance on massive lists, verify diffs, 
      // but for <100 nodes, innerHTML is fine.
      let html = '';
      
      // Sort: Offline first, then by name
      const sortedNodes = [...nodes].sort((a, b) => {
          if (a.status === b.status) return a.name.localeCompare(b.name);
          return a.status ? 1 : -1; // False (offline) comes first
      });

      sortedNodes.forEach(node => {
          const colorClass = node.status ? 'bg-green-500' : 'bg-red-500 shadow-[0_0_8px_rgba(239,68,68,0.6)]';
          const uptimeText = node.uptime || 'checking...';
          const statusLabel = node.status ? 'UP' : 'DOWN';
          const statusColor = node.status ? 'text-green-400' : 'text-red-400 font-bold';

          html += `
            <div class="host-row">
                <div class="flex items-center">
                    <div class="status-dot ${colorClass}"></div>
                    <div class="flex flex-col">
                        <span class="font-bold text-slate-200">${escapeHtml(node.name)}</span>
                        <span class="text-[10px] text-slate-500 font-mono">${escapeHtml(node.address)}</span>
                    </div>
                </div>
                <div class="text-right">
                    <div class="text-[10px] ${statusColor}">${statusLabel}</div>
                    <div class="status-text">${uptimeText}</div>
                </div>
            </div>
          `;
      });
      list.innerHTML = html;
  }

  function renderTree(nodes) {
    const container = document.getElementById('tree-container');
    container.innerHTML = ''; 

    const nodeMap = {};
    nodes.forEach(n => {
      n.primaryParentId = (n.primaryParentId && n.primaryParentId !== '') ? n.primaryParentId : null;
      n.activeParentId = (n.activeParentId && n.activeParentId !== '') ? n.activeParentId : n.primaryParentId;
      n.level = 0;
      nodeMap[n.id] = n;
    });

    for (let i=0;i<6;i++) {
      nodes.forEach(n => {
        if (n.primaryParentId && nodeMap[n.primaryParentId]) {
          n.level = Math.max(n.level, nodeMap[n.primaryParentId].level + 1);
        }
      });
    }

    const maxLevel = nodes.reduce((m,x)=>Math.max(m, x.level||0), 0);
    const levels = {};
    for (let l=0; l<=maxLevel; l++) { levels[l] = nodes.filter(n => n.level === l); }

    nodes.forEach(node => {
        const el = document.createElement('div');
        el.id = `node-${node.id}`;
        el.className = 'node-container card';
        
        let leftPos, topPos;
        if (node.x !== null && node.x !== undefined) {
            leftPos = node.x + '%';
        } else {
            const levelNodes = levels[node.level];
            const idx = levelNodes.indexOf(node);
            const slice = 100 / (levelNodes.length + 1);
            leftPos = (slice * (idx + 1)) + '%';
        }
        if (node.y !== null && node.y !== undefined) {
            topPos = node.y + '%';
        } else {
            topPos = (maxLevel===0) ? '50%' : (85 - (node.level * (70 / maxLevel))) + '%';
        }

        el.style.left = leftPos;
        el.style.top  = topPos;
        el.style.width = '140px';
        el.style.height = '140px';
        el.style.pointerEvents = 'auto';

        const isUp = node.status === true;
        const isFailover = node.activeParentId === node.secondaryParentId && node.secondaryParentId !== null;
        
        let iconHtml;
        if (node.iconType === 'url') {
             iconHtml = `<img src="${escapeHtml(node.icon||'')}" class="w-full h-full object-cover" onerror="this.style.display='none'">`;
        } else if (node.iconType === 'svg') {
             iconHtml = node.icon || '<i data-lucide="help-circle" class="w-8 h-8"></i>'; 
        } else {
             iconHtml = `<i data-lucide="${escapeHtml(node.icon||'circle')}" class="w-8 h-8"></i>`;
        }

        el.innerHTML = `
          <div style="display:flex; flex-direction:column; align-items:center; justify-content:center; height:100%; gap:6px; padding:10px; box-sizing:border-box;">
            <div style="width:48px; height:48px; border-radius:999px; display:flex; align-items:center; justify-content:center; background: rgba(0,0,0,0.15); border:1px solid rgba(255,255,255,0.03); overflow:hidden;">
                ${iconHtml}
            </div>
            <div style="text-align:center; width:100%; color:#e6eef8;">
              <div style="font-weight:700; font-size:12px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${escapeHtml(node.name || node.id)}</div>
              <div style="font-size:11px; color:var(--muted); font-family:monospace;">${escapeHtml(node.address||'')}</div>
              <div style="margin-top:6px; font-size:10px; padding:4px 6px; border-radius:999px; display:inline-block; color:${isFailover ? '#b45309' : (isUp ? '#16a34a' : '#ef4444')}; background:${isFailover ? 'rgba(251,191,36,0.08)' : (isUp ? 'rgba(34,197,94,0.06)' : 'rgba(239,68,68,0.06)')}; border:1px solid rgba(255,255,255,0.02); font-weight:700; letter-spacing:0.6px;">
                ${isUp ? 'ONLINE' : 'OFFLINE'}${isFailover ? ' (FAILOVER)' : ''}
              </div>
            </div>
          </div>
        `;
        container.appendChild(el);
    });

    lucide.createIcons();
    requestAnimationFrame(drawLines);
  }

  function drawLines() {
    const svg = document.getElementById('connections-layer');
    if (!svg) return;
    svg.setAttribute('width', '300%');
    svg.setAttribute('height', '300%');
    svg.innerHTML = ''; 

    networkData.forEach(node => {
      if (!node.activeParentId) return;
      const childEl = document.getElementById(`node-${node.id}`);
      const parentEl = document.getElementById(`node-${node.activeParentId}`);
      if (!childEl || !parentEl) return;

      const x1 = parentEl.offsetLeft;
      const y1 = parentEl.offsetTop;
      const x2 = childEl.offsetLeft;
      const y2 = childEl.offsetTop;

      const d = `M ${x1} ${y1} C ${x1} ${(y1 + y2) / 2} ${x2} ${(y1 + y2) / 2} ${x2} ${y2}`;
      
      const isFailover = node.activeParentId === node.secondaryParentId && node.secondaryParentId !== null;
      const baseColor = isFailover ? '#fbbf24' : (node.status ? '#22c55e' : '#ef4444');

      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      path.setAttribute('d', d); path.setAttribute('fill', 'none');
      path.setAttribute('stroke', baseColor); path.setAttribute('stroke-width', '1.5'); path.setAttribute('stroke-opacity', '0.4'); 
      svg.appendChild(path);

      if (node.status || isFailover) {
        const pathFwd = document.createElementNS("http://www.w3.org/2000/svg", "path");
        pathFwd.setAttribute('d', d); pathFwd.setAttribute('fill', 'none');
        pathFwd.setAttribute('stroke', baseColor); pathFwd.setAttribute('stroke-width', '1.5'); 
        pathFwd.setAttribute('stroke-dasharray', '8 8'); pathFwd.classList.add('animate-flow');
        svg.appendChild(pathFwd);

        const pathRev = document.createElementNS("http://www.w3.org/2000/svg", "path");
        pathRev.setAttribute('d', d); pathRev.setAttribute('fill', 'none');
        pathRev.setAttribute('stroke', baseColor); pathRev.setAttribute('stroke-width', '1.5'); 
        pathRev.setAttribute('stroke-dasharray', '8 8'); pathRev.setAttribute('stroke-opacity', '0.6'); 
        pathRev.classList.add('animate-flow-reverse');
        svg.appendChild(pathRev);
      }
    });
  }

  function loadStatusScript() {
    const old = document.getElementById('status-loader');
    if (old) old.remove();
    const s = document.createElement('script');
    s.id = 'status-loader';
    s.src = 'status.js?t=' + Date.now(); 
    s.async = true;
    document.head.appendChild(s);
  }

  setInterval(loadStatusScript, clientPollMs);
  loadStatusScript();
  window.addEventListener('resize', () => { if (networkData.length) renderTree(networkData); });
  function escapeHtml(s) { return String(s||'').replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;'); }
</script>
</body>
</html>
